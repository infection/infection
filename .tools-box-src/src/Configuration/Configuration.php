<?php

declare (strict_types=1);
namespace _HumbugBoxb47773b41c19\KevinGH\Box\Configuration;

use function array_diff;
use function array_filter;
use function array_flip;
use function array_key_exists;
use function array_keys;
use function array_map;
use function array_merge;
use function array_unique;
use function array_values;
use function array_walk;
use Closure;
use function constant;
use function current;
use DateTimeImmutable;
use DateTimeZone;
use function defined;
use function dirname;
use const E_USER_DEPRECATED;
use function explode;
use function file_exists;
use function getcwd;
use _HumbugBoxb47773b41c19\Humbug\PhpScoper\Configuration\Configuration as PhpScoperConfiguration;
use _HumbugBoxb47773b41c19\Humbug\PhpScoper\Container;
use function implode;
use function in_array;
use function intval;
use InvalidArgumentException;
use function is_array;
use function is_bool;
use function is_file;
use function is_link;
use function is_object;
use function is_readable;
use function is_string;
use function _HumbugBoxb47773b41c19\iter\map;
use function _HumbugBoxb47773b41c19\iter\toArray;
use function _HumbugBoxb47773b41c19\iter\values;
use _HumbugBoxb47773b41c19\KevinGH\Box\Annotation\CompactedFormatter;
use _HumbugBoxb47773b41c19\KevinGH\Box\Annotation\DocblockAnnotationParser;
use _HumbugBoxb47773b41c19\KevinGH\Box\Compactor\Compactor;
use _HumbugBoxb47773b41c19\KevinGH\Box\Compactor\Compactors;
use _HumbugBoxb47773b41c19\KevinGH\Box\Compactor\Php as PhpCompactor;
use _HumbugBoxb47773b41c19\KevinGH\Box\Compactor\PhpScoper as PhpScoperCompactor;
use _HumbugBoxb47773b41c19\KevinGH\Box\Composer\ComposerConfiguration;
use _HumbugBoxb47773b41c19\KevinGH\Box\Composer\ComposerFile;
use _HumbugBoxb47773b41c19\KevinGH\Box\Composer\ComposerFiles;
use function _HumbugBoxb47773b41c19\KevinGH\Box\FileSystem\canonicalize;
use function _HumbugBoxb47773b41c19\KevinGH\Box\FileSystem\file_contents;
use function _HumbugBoxb47773b41c19\KevinGH\Box\FileSystem\is_absolute_path;
use function _HumbugBoxb47773b41c19\KevinGH\Box\FileSystem\longest_common_base_path;
use function _HumbugBoxb47773b41c19\KevinGH\Box\FileSystem\make_path_absolute;
use function _HumbugBoxb47773b41c19\KevinGH\Box\FileSystem\make_path_relative;
use function _HumbugBoxb47773b41c19\KevinGH\Box\get_box_version;
use function _HumbugBoxb47773b41c19\KevinGH\Box\get_phar_compression_algorithms;
use function _HumbugBoxb47773b41c19\KevinGH\Box\get_phar_signing_algorithms;
use _HumbugBoxb47773b41c19\KevinGH\Box\Json\Json;
use _HumbugBoxb47773b41c19\KevinGH\Box\MapFile;
use _HumbugBoxb47773b41c19\KevinGH\Box\PhpScoper\SerializableScoper;
use function _HumbugBoxb47773b41c19\KevinGH\Box\unique_id;
use function krsort;
use function method_exists;
use Phar;
use _HumbugBoxb47773b41c19\phpDocumentor\Reflection\DocBlockFactory;
use function preg_match;
use function preg_replace;
use function property_exists;
use function realpath;
use RuntimeException;
use _HumbugBoxb47773b41c19\Seld\JsonLint\ParsingException;
use function sort;
use const SORT_STRING;
use SplFileInfo;
use function sprintf;
use stdClass;
use function str_starts_with;
use function strtoupper;
use _HumbugBoxb47773b41c19\Symfony\Component\Finder\Finder;
use _HumbugBoxb47773b41c19\Symfony\Component\Finder\SplFileInfo as SymfonySplFileInfo;
use _HumbugBoxb47773b41c19\Symfony\Component\Process\Exception\ProcessFailedException;
use _HumbugBoxb47773b41c19\Symfony\Component\Process\Process;
use _HumbugBoxb47773b41c19\Symfony\Component\VarDumper\Cloner\VarCloner;
use _HumbugBoxb47773b41c19\Symfony\Component\VarDumper\Dumper\CliDumper;
use Throwable;
use function trigger_error;
use function trim;
use _HumbugBoxb47773b41c19\Webmozart\Assert\Assert;
final class Configuration
{
    private const DEFAULT_OUTPUT_FALLBACK = 'test.phar';
    private const DEFAULT_MAIN_SCRIPT = 'index.php';
    private const DEFAULT_DATETIME_FORMAT = 'Y-m-d H:i:s T';
    private const DEFAULT_REPLACEMENT_SIGIL = '@';
    private const DEFAULT_SHEBANG = '#!/usr/bin/env php';
    private const DEFAULT_BANNER = <<<'BANNER'
Generated by Humbug Box %s.

@link https://github.com/humbug/box
BANNER;
    private const FILES_SETTINGS = ['directories', 'finder'];
    private const PHP_SCOPER_CONFIG = 'scoper.inc.php';
    private const DEFAULT_SIGNING_ALGORITHM = Phar::SHA1;
    private const DEFAULT_ALIAS_PREFIX = 'box-auto-generated-alias-';
    private const DEFAULT_IGNORED_ANNOTATIONS = ['abstract', 'access', 'annotation', 'api', 'attribute', 'attributes', 'author', 'category', 'code', 'codecoverageignore', 'codecoverageignoreend', 'codecoverageignorestart', 'copyright', 'deprec', 'deprecated', 'endcode', 'example', 'exception', 'filesource', 'final', 'fixme', 'global', 'ignore', 'ingroup', 'inheritdoc', 'internal', 'license', 'link', 'magic', 'method', 'name', 'override', 'package', 'package_version', 'param', 'private', 'property', 'required', 'return', 'see', 'since', 'static', 'staticvar', 'subpackage', 'suppresswarnings', 'target', 'throw', 'throws', 'todo', 'tutorial', 'usedby', 'uses', 'var', 'version'];
    private const ALGORITHM_KEY = 'algorithm';
    private const ALIAS_KEY = 'alias';
    private const ANNOTATIONS_KEY = 'annotations';
    private const IGNORED_ANNOTATIONS_KEY = 'ignore';
    private const AUTO_DISCOVERY_KEY = 'force-autodiscovery';
    private const BANNER_KEY = 'banner';
    private const BANNER_FILE_KEY = 'banner-file';
    private const BASE_PATH_KEY = 'base-path';
    private const BLACKLIST_KEY = 'blacklist';
    private const CHECK_REQUIREMENTS_KEY = 'check-requirements';
    private const CHMOD_KEY = 'chmod';
    private const COMPACTORS_KEY = 'compactors';
    private const COMPRESSION_KEY = 'compression';
    private const DATETIME_KEY = 'datetime';
    private const DATETIME_FORMAT_KEY = 'datetime-format';
    private const DATETIME_FORMAT_DEPRECATED_KEY = 'datetime_format';
    private const DIRECTORIES_KEY = 'directories';
    private const DIRECTORIES_BIN_KEY = 'directories-bin';
    private const DUMP_AUTOLOAD_KEY = 'dump-autoload';
    private const EXCLUDE_COMPOSER_FILES_KEY = 'exclude-composer-files';
    private const EXCLUDE_DEV_FILES_KEY = 'exclude-dev-files';
    private const FILES_KEY = 'files';
    private const FILES_BIN_KEY = 'files-bin';
    private const FINDER_KEY = 'finder';
    private const FINDER_BIN_KEY = 'finder-bin';
    private const GIT_KEY = 'git';
    private const GIT_COMMIT_KEY = 'git-commit';
    private const GIT_COMMIT_SHORT_KEY = 'git-commit-short';
    private const GIT_TAG_KEY = 'git-tag';
    private const GIT_VERSION_KEY = 'git-version';
    private const INTERCEPT_KEY = 'intercept';
    private const KEY_KEY = 'key';
    private const KEY_PASS_KEY = 'key-pass';
    private const MAIN_KEY = 'main';
    private const MAP_KEY = 'map';
    private const METADATA_KEY = 'metadata';
    private const OUTPUT_KEY = 'output';
    private const PHP_SCOPER_KEY = 'php-scoper';
    private const REPLACEMENT_SIGIL_KEY = 'replacement-sigil';
    private const REPLACEMENTS_KEY = 'replacements';
    private const SHEBANG_KEY = 'shebang';
    private const STUB_KEY = 'stub';
    private int|string|null $compressionAlgorithm;
    private ?string $mainScriptPath;
    private ?string $mainScriptContents;
    public static function create(?string $file, stdClass $raw) : self
    {
        $logger = new ConfigurationLogger();
        $basePath = self::retrieveBasePath($file, $raw, $logger);
        $composerFiles = self::retrieveComposerFiles($basePath);
        $dumpAutoload = self::retrieveDumpAutoload($raw, $composerFiles, $logger);
        $excludeComposerFiles = self::retrieveExcludeComposerFiles($raw, $logger);
        $mainScriptPath = self::retrieveMainScriptPath($raw, $basePath, $composerFiles->getComposerJson()->getDecodedContents(), $logger);
        $mainScriptContents = self::retrieveMainScriptContents($mainScriptPath);
        [$tmpOutputPath, $outputPath] = self::retrieveOutputPath($raw, $basePath, $mainScriptPath, $logger);
        $stubPath = self::retrieveStubPath($raw, $basePath, $logger);
        $isStubGenerated = self::retrieveIsStubGenerated($raw, $stubPath, $logger);
        $alias = self::retrieveAlias($raw, null !== $stubPath, $logger);
        $shebang = self::retrieveShebang($raw, $isStubGenerated, $logger);
        $stubBannerContents = self::retrieveStubBannerContents($raw, $isStubGenerated, $logger);
        $stubBannerPath = self::retrieveStubBannerPath($raw, $basePath, $isStubGenerated, $logger);
        if (null !== $stubBannerPath) {
            $stubBannerContents = file_contents($stubBannerPath);
        }
        $stubBannerContents = self::normalizeStubBannerContents($stubBannerContents);
        if (null !== $stubBannerPath && self::getDefaultBanner() === $stubBannerContents) {
            self::addRecommendationForDefaultValue($logger, self::BANNER_FILE_KEY);
        }
        $isInterceptsFileFunctions = self::retrieveInterceptsFileFunctions($raw, $isStubGenerated, $logger);
        $checkRequirements = self::retrieveCheckRequirements($raw, null !== $composerFiles->getComposerJson()->getPath(), null !== $composerFiles->getComposerLock()->getPath(), \false === $isStubGenerated && null === $stubPath, $logger);
        $excludeDevPackages = self::retrieveExcludeDevFiles($raw, $dumpAutoload, $logger);
        $devPackages = ComposerConfiguration::retrieveDevPackages($basePath, $composerFiles->getComposerJson()->getDecodedContents(), $composerFiles->getComposerLock()->getDecodedContents(), $excludeDevPackages);
        [$excludedPaths, $blacklistFilter] = self::retrieveBlacklistFilter($raw, $basePath, $logger, $tmpOutputPath, $outputPath, $mainScriptPath);
        $alwaysExcludedPaths = array_map(static fn(string $excludedPath): string => self::normalizePath($excludedPath, $basePath), array_filter([$tmpOutputPath, $outputPath, $mainScriptPath]));
        $autodiscoverFiles = self::autodiscoverFiles($file, $raw);
        $forceFilesAutodiscovery = self::retrieveForceFilesAutodiscovery($raw, $logger);
        $filesAggregate = self::collectFiles($raw, $basePath, $mainScriptPath, $blacklistFilter, $excludedPaths, $alwaysExcludedPaths, $devPackages, $composerFiles, $autodiscoverFiles, $forceFilesAutodiscovery, $logger);
        $binaryFilesAggregate = self::collectBinaryFiles($raw, $basePath, $blacklistFilter, $excludedPaths, $alwaysExcludedPaths, $devPackages, $logger);
        $compactors = self::retrieveCompactors($raw, $basePath, $logger);
        $compressionAlgorithm = self::retrieveCompressionAlgorithm($raw, $logger);
        $fileMode = self::retrieveFileMode($raw, $logger);
        $map = self::retrieveMap($raw, $logger);
        $fileMapper = new MapFile($basePath, $map);
        $metadata = self::retrieveMetadata($raw, $logger);
        $signingAlgorithm = self::retrieveSigningAlgorithm($raw, $logger);
        $promptForPrivateKey = self::retrievePromptForPrivateKey($raw, $signingAlgorithm, $logger);
        $privateKeyPath = self::retrievePrivateKeyPath($raw, $basePath, $signingAlgorithm, $logger);
        $privateKeyPassphrase = self::retrievePrivateKeyPassphrase($raw, $signingAlgorithm, $logger);
        $replacements = self::retrieveReplacements($raw, $file, $basePath, $logger);
        return new self($file, $alias, $basePath, $composerFiles->getComposerJson(), $composerFiles->getComposerLock(), $filesAggregate, $binaryFilesAggregate, $autodiscoverFiles || $forceFilesAutodiscovery, $dumpAutoload, $excludeComposerFiles, $excludeDevPackages, $compactors, $compressionAlgorithm, $fileMode, $mainScriptPath, $mainScriptContents, $fileMapper, $metadata, $tmpOutputPath, $outputPath, $privateKeyPassphrase, $privateKeyPath, $promptForPrivateKey, $replacements, $shebang, $signingAlgorithm, $stubBannerContents, $stubBannerPath, $stubPath, $isInterceptsFileFunctions, $isStubGenerated, $checkRequirements, $logger->getWarnings(), $logger->getRecommendations());
    }
    private function __construct(private ?string $file, private string $alias, private string $basePath, private ComposerFile $composerJson, private ComposerFile $composerLock, private array $files, private array $binaryFiles, private bool $autodiscoveredFiles, private bool $dumpAutoload, private bool $excludeComposerFiles, private bool $excludeDevFiles, private Compactors|array $compactors, ?int $compressionAlgorithm, private int|string|null $fileMode, ?string $mainScriptPath, ?string $mainScriptContents, private MapFile $fileMapper, private mixed $metadata, private string $tmpOutputPath, private string $outputPath, private ?string $privateKeyPassphrase, private ?string $privateKeyPath, private bool $promptForPrivateKey, private array $processedReplacements, private ?string $shebang, private int|string $signingAlgorithm, private ?string $stubBannerContents, private ?string $stubBannerPath, private ?string $stubPath, private bool $isInterceptFileFuncs, private bool $isStubGenerated, private bool $checkRequirements, private array $warnings, private array $recommendations)
    {
        Assert::nullOrInArray($compressionAlgorithm, get_phar_compression_algorithms(), sprintf('Invalid compression algorithm %%s, use one of "%s" instead.', implode('", "', array_keys(get_phar_compression_algorithms()))));
        if (null === $mainScriptPath) {
            Assert::null($mainScriptContents);
        } else {
            Assert::notNull($mainScriptContents);
        }
        $this->compressionAlgorithm = $compressionAlgorithm;
        $this->mainScriptPath = $mainScriptPath;
        $this->mainScriptContents = $mainScriptContents;
    }
    public function export() : string
    {
        $exportedConfig = clone $this;
        $basePath = $exportedConfig->basePath;
        $normalizePath = static function (null|SplFileInfo|string $path) use($basePath) : ?string {
            if (null === $path) {
                return null;
            }
            if ($path instanceof SplFileInfo) {
                $path = $path->getPathname();
            }
            return make_path_relative($path, $basePath);
        };
        $normalizeProperty = static function (&$property) use($normalizePath) : void {
            $property = $normalizePath($property);
        };
        $normalizeFiles = static function (&$files) use($normalizePath) : void {
            $files = array_map($normalizePath, $files);
            sort($files, SORT_STRING);
        };
        $normalizeFiles($exportedConfig->files);
        $normalizeFiles($exportedConfig->binaryFiles);
        $exportedConfig->composerJson = new ComposerFile($normalizePath($exportedConfig->composerJson->getPath()), $exportedConfig->composerJson->getDecodedContents());
        $exportedConfig->composerLock = new ComposerFile($normalizePath($exportedConfig->composerLock->getPath()), $exportedConfig->composerLock->getDecodedContents());
        $normalizeProperty($exportedConfig->file);
        $normalizeProperty($exportedConfig->mainScriptPath);
        $normalizeProperty($exportedConfig->tmpOutputPath);
        $normalizeProperty($exportedConfig->outputPath);
        $normalizeProperty($exportedConfig->privateKeyPath);
        $normalizeProperty($exportedConfig->stubBannerPath);
        $normalizeProperty($exportedConfig->stubPath);
        $exportedConfig->compressionAlgorithm = array_flip(get_phar_compression_algorithms())[$exportedConfig->compressionAlgorithm ?? Phar::NONE];
        $exportedConfig->signingAlgorithm = array_flip(get_phar_signing_algorithms())[$exportedConfig->signingAlgorithm];
        $exportedConfig->compactors = array_map('get_class', $exportedConfig->compactors->toArray());
        $exportedConfig->fileMode = '0' . \decoct($exportedConfig->fileMode);
        $cloner = new VarCloner();
        $cloner->setMaxItems(-1);
        $cloner->setMaxString(-1);
        $splInfoCaster = static fn(SplFileInfo $fileInfo): array => [$normalizePath($fileInfo)];
        $cloner->addCasters([SplFileInfo::class => $splInfoCaster, SymfonySplFileInfo::class => $splInfoCaster]);
        return (new CliDumper())->dump($cloner->cloneVar($exportedConfig), \true);
    }
    public function getConfigurationFile() : ?string
    {
        return $this->file;
    }
    public function getAlias() : string
    {
        return $this->alias;
    }
    public function getBasePath() : string
    {
        return $this->basePath;
    }
    public function getComposerJson() : ?string
    {
        return $this->composerJson->getPath();
    }
    public function getDecodedComposerJsonContents() : ?array
    {
        return null === $this->composerJson->getPath() ? null : $this->composerJson->getDecodedContents();
    }
    public function getComposerLock() : ?string
    {
        return $this->composerLock->getPath();
    }
    public function getDecodedComposerLockContents() : ?array
    {
        return null === $this->composerLock->getPath() ? null : $this->composerLock->getDecodedContents();
    }
    public function getFiles() : array
    {
        return $this->files;
    }
    public function getBinaryFiles() : array
    {
        return $this->binaryFiles;
    }
    public function hasAutodiscoveredFiles() : bool
    {
        return $this->autodiscoveredFiles;
    }
    public function dumpAutoload() : bool
    {
        return $this->dumpAutoload;
    }
    public function excludeComposerFiles() : bool
    {
        return $this->excludeComposerFiles;
    }
    public function excludeDevFiles() : bool
    {
        return $this->excludeDevFiles;
    }
    public function getCompactors() : Compactors
    {
        return $this->compactors;
    }
    public function getCompressionAlgorithm() : ?int
    {
        return $this->compressionAlgorithm;
    }
    public function getFileMode() : ?int
    {
        return $this->fileMode;
    }
    public function hasMainScript() : bool
    {
        return null !== $this->mainScriptPath;
    }
    public function getMainScriptPath() : string
    {
        Assert::notNull($this->mainScriptPath, 'Cannot retrieve the main script path: no main script configured.');
        return $this->mainScriptPath;
    }
    public function getMainScriptContents() : string
    {
        Assert::notNull($this->mainScriptPath, 'Cannot retrieve the main script contents: no main script configured.');
        return $this->mainScriptContents;
    }
    public function checkRequirements() : bool
    {
        return $this->checkRequirements;
    }
    public function getTmpOutputPath() : string
    {
        return $this->tmpOutputPath;
    }
    public function getOutputPath() : string
    {
        return $this->outputPath;
    }
    public function getFileMapper() : MapFile
    {
        return $this->fileMapper;
    }
    public function getMetadata() : mixed
    {
        return $this->metadata;
    }
    public function getPrivateKeyPassphrase() : ?string
    {
        return $this->privateKeyPassphrase;
    }
    public function getPrivateKeyPath() : ?string
    {
        return $this->privateKeyPath;
    }
    public function isPrivateKeyPrompt() : bool
    {
        return $this->promptForPrivateKey;
    }
    public function promptForPrivateKey() : bool
    {
        return $this->promptForPrivateKey;
    }
    public function getReplacements() : array
    {
        return $this->processedReplacements;
    }
    public function getShebang() : ?string
    {
        return $this->shebang;
    }
    public function getSigningAlgorithm() : int
    {
        return $this->signingAlgorithm;
    }
    public function getStubBannerContents() : ?string
    {
        return $this->stubBannerContents;
    }
    public function getStubBannerPath() : ?string
    {
        return $this->stubBannerPath;
    }
    public function getStubPath() : ?string
    {
        return $this->stubPath;
    }
    public function isInterceptFileFuncs() : bool
    {
        return $this->isInterceptFileFuncs;
    }
    public function isStubGenerated() : bool
    {
        return $this->isStubGenerated;
    }
    public function getWarnings() : array
    {
        return $this->warnings;
    }
    public function getRecommendations() : array
    {
        return $this->recommendations;
    }
    private static function retrieveAlias(stdClass $raw, bool $userStubUsed, ConfigurationLogger $logger) : string
    {
        self::checkIfDefaultValue($logger, $raw, self::ALIAS_KEY);
        if (\false === isset($raw->{self::ALIAS_KEY})) {
            return unique_id(self::DEFAULT_ALIAS_PREFIX) . '.phar';
        }
        $alias = trim($raw->{self::ALIAS_KEY});
        Assert::notEmpty($alias, 'A PHAR alias cannot be empty when provided.');
        if ($userStubUsed) {
            $logger->addWarning(sprintf('The "%s" setting has been set but is ignored since a custom stub path is used', self::ALIAS_KEY));
        }
        return $alias;
    }
    private static function retrieveBasePath(?string $file, stdClass $raw, ConfigurationLogger $logger) : string
    {
        if (null === $file) {
            return getcwd();
        }
        if (\false === isset($raw->{self::BASE_PATH_KEY})) {
            return realpath(dirname($file));
        }
        $basePath = trim($raw->{self::BASE_PATH_KEY});
        Assert::directory($basePath, 'The base path %s is not a directory or does not exist.');
        $basePath = realpath($basePath);
        $defaultPath = realpath(dirname($file));
        if ($basePath === $defaultPath) {
            self::addRecommendationForDefaultValue($logger, self::BASE_PATH_KEY);
        }
        return $basePath;
    }
    private static function autodiscoverFiles(?string $file, stdClass $raw) : bool
    {
        if (null === $file) {
            return \true;
        }
        $associativeRaw = (array) $raw;
        return self::FILES_SETTINGS === array_diff(self::FILES_SETTINGS, array_keys($associativeRaw));
    }
    private static function retrieveForceFilesAutodiscovery(stdClass $raw, ConfigurationLogger $logger) : bool
    {
        self::checkIfDefaultValue($logger, $raw, self::AUTO_DISCOVERY_KEY, \false);
        return $raw->{self::AUTO_DISCOVERY_KEY} ?? \false;
    }
    private static function retrieveBlacklistFilter(stdClass $raw, string $basePath, ConfigurationLogger $logger, ?string ...$excludedPaths) : array
    {
        $blacklist = array_flip(self::retrieveBlacklist($raw, $basePath, $logger, ...$excludedPaths));
        $blacklistFilter = static function (SplFileInfo $file) use($blacklist) : ?bool {
            if ($file->isLink()) {
                return \false;
            }
            if (\false === $file->getRealPath()) {
                return \false;
            }
            if (array_key_exists($file->getRealPath(), $blacklist)) {
                return \false;
            }
            return null;
        };
        return [array_keys($blacklist), $blacklistFilter];
    }
    private static function retrieveBlacklist(stdClass $raw, string $basePath, ConfigurationLogger $logger, ?string ...$excludedPaths) : array
    {
        self::checkIfDefaultValue($logger, $raw, self::BLACKLIST_KEY, []);
        $normalizedBlacklist = array_map(static fn(string $excludedPath): string => self::normalizePath($excludedPath, $basePath), array_filter($excludedPaths));
        $blacklist = $raw->{self::BLACKLIST_KEY} ?? [];
        foreach ($blacklist as $file) {
            $normalizedBlacklist[] = self::normalizePath($file, $basePath);
            $normalizedBlacklist[] = canonicalize(make_path_relative(trim($file), $basePath));
        }
        return array_unique($normalizedBlacklist);
    }
    private static function collectFiles(stdClass $raw, string $basePath, ?string $mainScriptPath, Closure $blacklistFilter, array $excludedPaths, array $alwaysExcludedPaths, array $devPackages, ComposerFiles $composerFiles, bool $autodiscoverFiles, bool $forceFilesAutodiscovery, ConfigurationLogger $logger) : array
    {
        $files = [self::retrieveFiles($raw, self::FILES_KEY, $basePath, $composerFiles, $alwaysExcludedPaths, $logger)];
        if ($autodiscoverFiles || $forceFilesAutodiscovery) {
            [$filesToAppend, $directories] = self::retrieveAllDirectoriesToInclude($basePath, $composerFiles->getComposerJson()->getDecodedContents(), $devPackages, $composerFiles->getPaths(), $excludedPaths);
            $files[] = self::wrapInSplFileInfo($filesToAppend);
            $files[] = self::retrieveAllFiles($basePath, $directories, $mainScriptPath, $blacklistFilter, $excludedPaths, $devPackages);
        }
        if (\false === $autodiscoverFiles) {
            $files[] = self::retrieveDirectories($raw, self::DIRECTORIES_KEY, $basePath, $blacklistFilter, $excludedPaths, $logger);
            $filesFromFinders = self::retrieveFilesFromFinders($raw, self::FINDER_KEY, $basePath, $blacklistFilter, $devPackages, $logger);
            foreach ($filesFromFinders as $filesFromFinder) {
                $files[] = $filesFromFinder;
            }
            $files[] = self::wrapInSplFileInfo($composerFiles->getPaths());
        }
        return self::retrieveFilesAggregate(...$files);
    }
    private static function collectBinaryFiles(stdClass $raw, string $basePath, Closure $blacklistFilter, array $excludedPaths, array $alwaysExcludedPaths, array $devPackages, ConfigurationLogger $logger) : array
    {
        $binaryFiles = self::retrieveFiles($raw, self::FILES_BIN_KEY, $basePath, ComposerFiles::createEmpty(), $alwaysExcludedPaths, $logger);
        $binaryDirectories = self::retrieveDirectories($raw, self::DIRECTORIES_BIN_KEY, $basePath, $blacklistFilter, $excludedPaths, $logger);
        $binaryFilesFromFinders = self::retrieveFilesFromFinders($raw, self::FINDER_BIN_KEY, $basePath, $blacklistFilter, $devPackages, $logger);
        return self::retrieveFilesAggregate($binaryFiles, $binaryDirectories, ...$binaryFilesFromFinders);
    }
    private static function retrieveFiles(stdClass $raw, string $key, string $basePath, ComposerFiles $composerFiles, array $excludedFiles, ConfigurationLogger $logger) : array
    {
        self::checkIfDefaultValue($logger, $raw, $key, []);
        $excludedFiles = array_flip($excludedFiles);
        $files = array_filter([$composerFiles->getComposerJson()->getPath(), $composerFiles->getComposerLock()->getPath()]);
        if (\false === isset($raw->{$key})) {
            return self::wrapInSplFileInfo($files);
        }
        if ([] === (array) $raw->{$key}) {
            return self::wrapInSplFileInfo($files);
        }
        $files = array_merge((array) $raw->{$key}, $files);
        Assert::allString($files);
        $normalizePath = static function (string $file) use($basePath, $key, $excludedFiles) : ?SplFileInfo {
            $file = self::normalizePath($file, $basePath);
            Assert::false(is_link($file), sprintf('Cannot add the link "%s": links are not supported.', $file));
            Assert::file($file, sprintf('"%s" must contain a list of existing files. Could not find %%s.', $key));
            return array_key_exists($file, $excludedFiles) ? null : new SplFileInfo($file);
        };
        return array_filter(array_map($normalizePath, $files));
    }
    private static function retrieveDirectories(stdClass $raw, string $key, string $basePath, Closure $blacklistFilter, array $excludedPaths, ConfigurationLogger $logger) : iterable
    {
        $directories = self::retrieveDirectoryPaths($raw, $key, $basePath, $logger);
        if ([] !== $directories) {
            $finder = Finder::create()->files()->filter($blacklistFilter)->ignoreVCS(\true)->in($directories);
            foreach ($excludedPaths as $excludedPath) {
                $finder->notPath($excludedPath);
            }
            return $finder;
        }
        return [];
    }
    private static function retrieveFilesFromFinders(stdClass $raw, string $key, string $basePath, Closure $blacklistFilter, array $devPackages, ConfigurationLogger $logger) : array
    {
        self::checkIfDefaultValue($logger, $raw, $key, []);
        if (\false === isset($raw->{$key})) {
            return [];
        }
        $finder = $raw->{$key};
        return self::processFinders($finder, $basePath, $blacklistFilter, $devPackages);
    }
    private static function retrieveFilesAggregate(iterable ...$fileIterators) : array
    {
        $files = [];
        foreach ($fileIterators as $fileIterator) {
            foreach ($fileIterator as $file) {
                $files[(string) $file] = $file;
            }
        }
        return array_values($files);
    }
    private static function processFinders(array $findersConfig, string $basePath, Closure $blacklistFilter, array $devPackages) : array
    {
        $processFinderConfig = static fn(stdClass $config) => self::processFinder($config, $basePath, $blacklistFilter, $devPackages);
        return array_map($processFinderConfig, $findersConfig);
    }
    private static function processFinder(stdClass $config, string $basePath, Closure $blacklistFilter, array $devPackages) : Finder
    {
        $finder = Finder::create()->files()->filter($blacklistFilter)->filter(static function (SplFileInfo $fileInfo) use($devPackages) : bool {
            foreach ($devPackages as $devPackage) {
                if ($devPackage === longest_common_base_path([$devPackage, $fileInfo->getRealPath()])) {
                    return \false;
                }
            }
            return \true;
        })->ignoreVCS(\true);
        $normalizedConfig = (static function (array $config, Finder $finder) : array {
            $normalizedConfig = [];
            foreach ($config as $method => $arguments) {
                $method = trim($method);
                $arguments = (array) $arguments;
                Assert::methodExists($finder, $method);
                $normalizedConfig[$method] = $arguments;
            }
            krsort($normalizedConfig);
            return $normalizedConfig;
        })((array) $config, $finder);
        $createNormalizedDirectories = static function (string $directory) use($basePath) : ?string {
            $directory = self::normalizePath($directory, $basePath);
            Assert::false(is_link($directory), sprintf('Cannot append the link "%s" to the Finder: links are not supported.', $directory));
            Assert::directory($directory);
            return $directory;
        };
        $normalizeFileOrDirectory = static function (?string &$fileOrDirectory) use($basePath, $blacklistFilter) : void {
            if (null === $fileOrDirectory) {
                return;
            }
            $fileOrDirectory = self::normalizePath($fileOrDirectory, $basePath);
            Assert::false(is_link($fileOrDirectory), sprintf('Cannot append the link "%s" to the Finder: links are not supported.', $fileOrDirectory));
            Assert::true(file_exists($fileOrDirectory), sprintf('Path "%s" was expected to be a file or directory. It may be a symlink (which are unsupported).', $fileOrDirectory));
            if (\false === is_file($fileOrDirectory)) {
                Assert::directory($fileOrDirectory);
            } else {
                Assert::file($fileOrDirectory);
            }
            if (\false === $blacklistFilter(new SplFileInfo($fileOrDirectory))) {
                $fileOrDirectory = null;
            }
        };
        foreach ($normalizedConfig as $method => $arguments) {
            if ('in' === $method) {
                $normalizedConfig[$method] = $arguments = array_map($createNormalizedDirectories, $arguments);
            }
            if ('exclude' === $method) {
                $arguments = array_unique(array_map('trim', $arguments));
            }
            if ('append' === $method) {
                array_walk($arguments, $normalizeFileOrDirectory);
                $arguments = [array_filter($arguments)];
            }
            foreach ($arguments as $argument) {
                $finder->{$method}($argument);
            }
        }
        return $finder;
    }
    private static function retrieveAllDirectoriesToInclude(string $basePath, ?array $decodedJsonContents, array $devPackages, array $filesToAppend, array $excludedPaths) : array
    {
        $toString = static fn(string|SplFileInfo $file): string => (string) $file;
        if (null !== $decodedJsonContents && array_key_exists('vendor-dir', $decodedJsonContents)) {
            $vendorDir = self::normalizePath($decodedJsonContents['vendor-dir'], $basePath);
        } else {
            $vendorDir = self::normalizePath('vendor', $basePath);
        }
        if (file_exists($vendorDir)) {
            $requiredComposerFiles = ['installed.json', 'installed.php', 'InstalledVersions.php'];
            foreach ($requiredComposerFiles as $requiredComposerFile) {
                $normalizePath = self::normalizePath($vendorDir . '/composer/' . $requiredComposerFile, $basePath);
                if (file_exists($normalizePath)) {
                    $filesToAppend[] = $normalizePath;
                }
            }
            $vendorPackages = toArray(values(map($toString, Finder::create()->in($vendorDir)->directories()->depth(1)->ignoreUnreadableDirs()->filter(static function (SplFileInfo $fileInfo) : ?bool {
                if ($fileInfo->isLink()) {
                    return \false;
                }
                return null;
            }))));
            $vendorPackages = array_diff($vendorPackages, $devPackages);
            if (null === $decodedJsonContents || \false === array_key_exists('autoload', $decodedJsonContents)) {
                $files = toArray(values(map($toString, Finder::create()->in($basePath)->files()->depth(0))));
                $directories = toArray(values(map($toString, Finder::create()->in($basePath)->notPath('vendor')->directories()->depth(0))));
                return [array_merge(array_diff($files, $excludedPaths), $filesToAppend), array_merge(array_diff($directories, $excludedPaths), $vendorPackages)];
            }
            $paths = $vendorPackages;
        } else {
            $paths = [];
        }
        $autoload = $decodedJsonContents['autoload'] ?? [];
        if (array_key_exists('psr-4', $autoload)) {
            foreach ($autoload['psr-4'] as $path) {
                $composerPaths = (array) $path;
                foreach ($composerPaths as $composerPath) {
                    $paths[] = '' !== trim($composerPath) ? $composerPath : $basePath;
                }
            }
        }
        if (array_key_exists('psr-0', $autoload)) {
            foreach ($autoload['psr-0'] as $path) {
                $composerPaths = (array) $path;
                foreach ($composerPaths as $composerPath) {
                    $paths[] = '' !== trim($composerPath) ? $composerPath : $basePath;
                }
            }
        }
        if (array_key_exists('classmap', $autoload)) {
            foreach ($autoload['classmap'] as $path) {
                $paths[] = $path;
            }
        }
        $normalizePath = static fn(string $path): string => is_absolute_path($path) ? canonicalize($path) : self::normalizePath(trim($path, '/ '), $basePath);
        if (array_key_exists('files', $autoload)) {
            foreach ($autoload['files'] as $path) {
                $path = $normalizePath($path);
                Assert::file($path);
                Assert::false(is_link($path), 'Cannot add the link "' . $path . '": links are not supported.');
                $filesToAppend[] = $path;
            }
        }
        $files = $filesToAppend;
        $directories = [];
        foreach ($paths as $path) {
            $path = $normalizePath($path);
            Assert::true(file_exists($path), 'File or directory "' . $path . '" was expected to exist.');
            Assert::false(is_link($path), 'Cannot add the link "' . $path . '": links are not supported.');
            if (is_file($path)) {
                $files[] = $path;
            } else {
                $directories[] = $path;
            }
        }
        [$files, $directories] = [array_unique($files), array_unique($directories)];
        return [array_diff($files, $excludedPaths), array_diff($directories, $excludedPaths)];
    }
    private static function retrieveAllFiles(string $basePath, array $directories, ?string $mainScriptPath, Closure $blacklistFilter, array $excludedPaths, array $devPackages) : iterable
    {
        if ([] === $directories) {
            return [];
        }
        $relativeDevPackages = array_map(static fn(string $packagePath): string => make_path_relative($packagePath, $basePath), $devPackages);
        $finder = Finder::create()->files()->filter($blacklistFilter)->exclude($relativeDevPackages)->ignoreVCS(\true)->ignoreDotFiles(\true)->notName('composer.json')->notName('composer.lock')->notName('Makefile')->notName('Vagrantfile')->notName('phpstan*.neon*')->notName('infection*.json*')->notName('humbug*.json*')->notName('easy-coding-standard.neon*')->notName('phpbench.json*')->notName('phpcs.xml*')->notName('psalm.xml*')->notName('scoper.inc*')->notName('box*.json*')->notName('phpdoc*.xml*')->notName('codecov.yml*')->notName('Dockerfile')->exclude('build')->exclude('dist')->exclude('example')->exclude('examples')->notName('*.md')->notName('*.rst')->notName('/^readme((?!\\.php)(\\..*+))?$/i')->notName('/^upgrade((?!\\.php)(\\..*+))?$/i')->notName('/^contributing((?!\\.php)(\\..*+))?$/i')->notName('/^changelog((?!\\.php)(\\..*+))?$/i')->notName('/^authors?((?!\\.php)(\\..*+))?$/i')->notName('/^conduct((?!\\.php)(\\..*+))?$/i')->notName('/^todo((?!\\.php)(\\..*+))?$/i')->exclude('doc')->exclude('docs')->exclude('documentation')->notName('*~')->notName('*.back')->notName('*.swp')->notName('*Test.php')->exclude('test')->exclude('Test')->exclude('tests')->exclude('Tests')->notName('/phpunit.*\\.xml(.dist)?/')->notName('/behat.*\\.yml(.dist)?/')->exclude('spec')->exclude('specs')->exclude('features')->exclude('travis')->notName('travis.yml')->notName('appveyor.yml')->notName('build.xml*');
        if (null !== $mainScriptPath) {
            $finder->notPath(make_path_relative($mainScriptPath, $basePath));
        }
        $finder->in($directories);
        $excludedPaths = array_unique(array_filter(array_map(static fn(string $path): string => make_path_relative($path, $basePath), $excludedPaths), static fn(string $path): bool => !str_starts_with($path, '..')));
        foreach ($excludedPaths as $excludedPath) {
            $finder->notPath($excludedPath);
        }
        return $finder;
    }
    private static function retrieveDirectoryPaths(stdClass $raw, string $key, string $basePath, ConfigurationLogger $logger) : array
    {
        self::checkIfDefaultValue($logger, $raw, $key, []);
        if (\false === isset($raw->{$key})) {
            return [];
        }
        $directories = $raw->{$key};
        $normalizeDirectory = static function (string $directory) use($basePath, $key) : string {
            $directory = self::normalizePath($directory, $basePath);
            Assert::false(is_link($directory), sprintf('Cannot add the link "%s": links are not supported.', $directory));
            Assert::directory($directory, sprintf('"%s" must contain a list of existing directories. Could not find %%s.', $key));
            return $directory;
        };
        return array_map($normalizeDirectory, $directories);
    }
    private static function normalizePath(string $file, string $basePath) : string
    {
        return make_path_absolute(trim($file), $basePath);
    }
    private static function wrapInSplFileInfo(array $files) : array
    {
        return array_map(static fn(string $file): SplFileInfo => new SplFileInfo($file), $files);
    }
    private static function retrieveDumpAutoload(stdClass $raw, ComposerFiles $composerFiles, ConfigurationLogger $logger) : bool
    {
        self::checkIfDefaultValue($logger, $raw, self::DUMP_AUTOLOAD_KEY, null);
        $canDumpAutoload = null !== $composerFiles->getComposerJson()->getPath() && (null === $composerFiles->getComposerLock()->getPath() && null === $composerFiles->getInstalledJson()->getPath() || null !== $composerFiles->getComposerLock()->getPath() && null !== $composerFiles->getInstalledJson()->getPath() || null === $composerFiles->getComposerLock()->getPath() && null !== $composerFiles->getInstalledJson()->getPath() && [] === $composerFiles->getInstalledJson()->getDecodedContents());
        if ($canDumpAutoload) {
            self::checkIfDefaultValue($logger, $raw, self::DUMP_AUTOLOAD_KEY, \true);
        }
        if (\false === property_exists($raw, self::DUMP_AUTOLOAD_KEY)) {
            return $canDumpAutoload;
        }
        $dumpAutoload = $raw->{self::DUMP_AUTOLOAD_KEY} ?? \true;
        if (\false === $canDumpAutoload && $dumpAutoload) {
            $logger->addWarning(sprintf('The "%s" setting has been set but has been ignored because the composer.json, composer.lock' . ' and vendor/composer/installed.json files are necessary but could not be found.', self::DUMP_AUTOLOAD_KEY));
            return \false;
        }
        return $canDumpAutoload && \false !== $dumpAutoload;
    }
    private static function retrieveExcludeDevFiles(stdClass $raw, bool $dumpAutoload, ConfigurationLogger $logger) : bool
    {
        self::checkIfDefaultValue($logger, $raw, self::EXCLUDE_DEV_FILES_KEY, $dumpAutoload);
        if (\false === property_exists($raw, self::EXCLUDE_DEV_FILES_KEY)) {
            return $dumpAutoload;
        }
        $excludeDevFiles = $raw->{self::EXCLUDE_DEV_FILES_KEY} ?? $dumpAutoload;
        if (\true === $excludeDevFiles && \false === $dumpAutoload) {
            $logger->addWarning(sprintf('The "%s" setting has been set but has been ignored because the Composer autoloader is not dumped', self::EXCLUDE_DEV_FILES_KEY));
            return \false;
        }
        return $excludeDevFiles;
    }
    private static function retrieveExcludeComposerFiles(stdClass $raw, ConfigurationLogger $logger) : bool
    {
        self::checkIfDefaultValue($logger, $raw, self::EXCLUDE_COMPOSER_FILES_KEY, \true);
        return $raw->{self::EXCLUDE_COMPOSER_FILES_KEY} ?? \true;
    }
    private static function retrieveCompactors(stdClass $raw, string $basePath, ConfigurationLogger $logger) : Compactors
    {
        self::checkIfDefaultValue($logger, $raw, self::COMPACTORS_KEY, []);
        $compactorClasses = array_unique((array) ($raw->{self::COMPACTORS_KEY} ?? []));
        $ignoredAnnotations = self::retrievePhpCompactorIgnoredAnnotations($raw, $compactorClasses, $logger);
        if (\false === isset($raw->{self::COMPACTORS_KEY})) {
            return new Compactors();
        }
        $compactors = new Compactors(...self::createCompactors($raw, $basePath, $compactorClasses, $ignoredAnnotations, $logger));
        self::checkCompactorsOrder($logger, $compactors);
        return $compactors;
    }
    private static function createCompactors(stdClass $raw, string $basePath, array $compactorClasses, array $ignoredAnnotations, ConfigurationLogger $logger) : array
    {
        return array_map(static function (string $class) use($raw, $basePath, $logger, $ignoredAnnotations) : Compactor {
            Assert::classExists($class, 'The compactor class %s does not exist.');
            Assert::isAOf($class, Compactor::class, sprintf('The class "%s" is not a compactor class.', $class));
            if (in_array($class, [PhpCompactor::class, 'KevinGH\\Box' . '\\Compactor\\Php'], \true)) {
                return self::createPhpCompactor($ignoredAnnotations);
            }
            if (in_array($class, [PhpScoperCompactor::class, 'KevinGH\\Box' . '\\Compactor\\PhpScoper'], \true)) {
                return self::createPhpScoperCompactor($raw, $basePath, $logger);
            }
            return new $class();
        }, $compactorClasses);
    }
    private static function checkCompactorsOrder(ConfigurationLogger $logger, Compactors $compactors) : void
    {
        $scoperCompactor = \false;
        foreach ($compactors->toArray() as $compactor) {
            if ($compactor instanceof PhpScoperCompactor) {
                $scoperCompactor = \true;
            }
            if ($compactor instanceof PhpCompactor) {
                if (\true === $scoperCompactor) {
                    $logger->addRecommendation('The PHP compactor has been registered after the PhpScoper compactor. It is ' . 'recommended to register the PHP compactor before for a clearer code and faster processing.');
                }
                break;
            }
        }
    }
    private static function retrieveCompressionAlgorithm(stdClass $raw, ConfigurationLogger $logger) : ?int
    {
        self::checkIfDefaultValue($logger, $raw, self::COMPRESSION_KEY, 'NONE');
        if (\false === isset($raw->{self::COMPRESSION_KEY})) {
            return null;
        }
        $knownAlgorithmNames = array_keys(get_phar_compression_algorithms());
        Assert::inArray($raw->{self::COMPRESSION_KEY}, $knownAlgorithmNames, sprintf('Invalid compression algorithm %%s, use one of "%s" instead.', implode('", "', $knownAlgorithmNames)));
        $value = get_phar_compression_algorithms()[$raw->{self::COMPRESSION_KEY}];
        if (Phar::NONE === $value) {
            return null;
        }
        return $value;
    }
    private static function retrieveFileMode(stdClass $raw, ConfigurationLogger $logger) : ?int
    {
        if (property_exists($raw, self::CHMOD_KEY) && null === $raw->{self::CHMOD_KEY}) {
            self::addRecommendationForDefaultValue($logger, self::CHMOD_KEY);
        }
        $defaultChmod = intval(0755, 8);
        if (isset($raw->{self::CHMOD_KEY})) {
            $chmod = intval($raw->{self::CHMOD_KEY}, 8);
            if ($defaultChmod === $chmod) {
                self::addRecommendationForDefaultValue($logger, self::CHMOD_KEY);
            }
            return $chmod;
        }
        return $defaultChmod;
    }
    private static function retrieveMainScriptPath(stdClass $raw, string $basePath, ?array $decodedJsonContents, ConfigurationLogger $logger) : ?string
    {
        $firstBin = \false;
        if (null !== $decodedJsonContents && array_key_exists('bin', $decodedJsonContents)) {
            $firstBin = current((array) $decodedJsonContents['bin']);
            if (\false !== $firstBin) {
                $firstBin = self::normalizePath($firstBin, $basePath);
            }
        }
        if (isset($raw->{self::MAIN_KEY})) {
            $main = $raw->{self::MAIN_KEY};
            if (is_string($main)) {
                $main = self::normalizePath($main, $basePath);
                if ($main === $firstBin) {
                    $logger->addRecommendation(sprintf('The "%s" setting can be omitted since is set to its default value', self::MAIN_KEY));
                }
            }
        } else {
            $main = \false !== $firstBin ? $firstBin : self::normalizePath(self::DEFAULT_MAIN_SCRIPT, $basePath);
        }
        if (is_bool($main)) {
            Assert::false($main, 'Cannot "enable" a main script: either disable it with `false` or give the main script file path.');
            return null;
        }
        Assert::file($main);
        return $main;
    }
    private static function retrieveMainScriptContents(?string $mainScriptPath) : ?string
    {
        if (null === $mainScriptPath) {
            return null;
        }
        $contents = file_contents($mainScriptPath);
        return preg_replace('/^#!.*\\s*/', '', $contents);
    }
    private static function retrieveComposerFiles(string $basePath) : ComposerFiles
    {
        $retrieveFileAndContents = static function (string $file) : ?ComposerFile {
            $json = new Json();
            if (\false === file_exists($file) || \false === is_file($file) || \false === is_readable($file)) {
                return ComposerFile::createEmpty();
            }
            try {
                $contents = (array) $json->decodeFile($file, \true);
            } catch (ParsingException $exception) {
                throw new InvalidArgumentException(sprintf('Expected the file "%s" to be a valid composer.json file but an error has been found: %s', $file, $exception->getMessage()), 0, $exception);
            }
            return new ComposerFile($file, $contents);
        };
        return new ComposerFiles($retrieveFileAndContents(canonicalize($basePath . '/composer.json')), $retrieveFileAndContents(canonicalize($basePath . '/composer.lock')), $retrieveFileAndContents(canonicalize($basePath . '/vendor/composer/installed.json')));
    }
    private static function retrieveMap(stdClass $raw, ConfigurationLogger $logger) : array
    {
        self::checkIfDefaultValue($logger, $raw, self::MAP_KEY, []);
        if (\false === isset($raw->{self::MAP_KEY})) {
            return [];
        }
        $map = [];
        foreach ((array) $raw->{self::MAP_KEY} as $item) {
            $processed = [];
            foreach ($item as $match => $replace) {
                $processed[canonicalize(trim($match))] = canonicalize(trim($replace));
            }
            if (isset($processed['_empty_'])) {
                $processed[''] = $processed['_empty_'];
                unset($processed['_empty_']);
            }
            $map[] = $processed;
        }
        return $map;
    }
    private static function retrieveMetadata(stdClass $raw, ConfigurationLogger $logger)
    {
        self::checkIfDefaultValue($logger, $raw, self::METADATA_KEY);
        if (\false === isset($raw->{self::METADATA_KEY})) {
            return null;
        }
        $metadata = $raw->{self::METADATA_KEY};
        return is_object($metadata) ? (array) $metadata : $metadata;
    }
    private static function retrieveOutputPath(stdClass $raw, string $basePath, ?string $mainScriptPath, ConfigurationLogger $logger) : array
    {
        $defaultPath = null;
        if (null !== $mainScriptPath && 1 === preg_match('/^(?<main>.*?)(?:\\.[\\p{L}\\d]+)?$/u', $mainScriptPath, $matches)) {
            $defaultPath = $matches['main'] . '.phar';
        }
        if (isset($raw->{self::OUTPUT_KEY})) {
            $path = self::normalizePath($raw->{self::OUTPUT_KEY}, $basePath);
            if ($path === $defaultPath) {
                self::addRecommendationForDefaultValue($logger, self::OUTPUT_KEY);
            }
        } elseif (null !== $defaultPath) {
            $path = $defaultPath;
        } else {
            $path = self::normalizePath(self::DEFAULT_OUTPUT_FALLBACK, $basePath);
        }
        $tmp = $real = $path;
        if (!\str_ends_with($real, '.phar')) {
            $tmp .= '.phar';
        }
        return [$tmp, $real];
    }
    private static function retrievePrivateKeyPath(stdClass $raw, string $basePath, int $signingAlgorithm, ConfigurationLogger $logger) : ?string
    {
        if (property_exists($raw, self::KEY_KEY) && Phar::OPENSSL !== $signingAlgorithm) {
            if (null === $raw->{self::KEY_KEY}) {
                $logger->addRecommendation('The setting "key" has been set but is unnecessary since the signing algorithm is not "OPENSSL".');
            } else {
                $logger->addWarning('The setting "key" has been set but is ignored since the signing algorithm is not "OPENSSL".');
            }
            return null;
        }
        if (!isset($raw->{self::KEY_KEY})) {
            Assert::true(Phar::OPENSSL !== $signingAlgorithm, 'Expected to have a private key for OpenSSL signing but none have been provided.');
            return null;
        }
        $path = self::normalizePath($raw->{self::KEY_KEY}, $basePath);
        Assert::file($path);
        return $path;
    }
    private static function retrievePrivateKeyPassphrase(stdClass $raw, int $algorithm, ConfigurationLogger $logger) : ?string
    {
        self::checkIfDefaultValue($logger, $raw, self::KEY_PASS_KEY);
        if (\false === property_exists($raw, self::KEY_PASS_KEY)) {
            return null;
        }
        $keyPass = $raw->{self::KEY_PASS_KEY};
        if (Phar::OPENSSL !== $algorithm) {
            if (\false === $keyPass || null === $keyPass) {
                $logger->addRecommendation(sprintf('The setting "%s" has been set but is unnecessary since the signing algorithm is ' . 'not "OPENSSL".', self::KEY_PASS_KEY));
            } else {
                $logger->addWarning(sprintf('The setting "%s" has been set but ignored the signing algorithm is not "OPENSSL".', self::KEY_PASS_KEY));
            }
            return null;
        }
        return is_string($keyPass) ? $keyPass : null;
    }
    private static function retrieveReplacements(stdClass $raw, ?string $file, string $path, ConfigurationLogger $logger) : array
    {
        self::checkIfDefaultValue($logger, $raw, self::REPLACEMENTS_KEY, new stdClass());
        if (null === $file) {
            return [];
        }
        $replacements = isset($raw->{self::REPLACEMENTS_KEY}) ? (array) $raw->{self::REPLACEMENTS_KEY} : [];
        if (null !== ($git = self::retrievePrettyGitPlaceholder($raw, $logger))) {
            $replacements[$git] = self::retrievePrettyGitTag($path);
        }
        if (null !== ($git = self::retrieveGitHashPlaceholder($raw, $logger))) {
            $replacements[$git] = self::retrieveGitHash($path);
        }
        if (null !== ($git = self::retrieveGitShortHashPlaceholder($raw, $logger))) {
            $replacements[$git] = self::retrieveGitHash($path, \true);
        }
        if (null !== ($git = self::retrieveGitTagPlaceholder($raw, $logger))) {
            $replacements[$git] = self::retrieveGitTag($path);
        }
        if (null !== ($git = self::retrieveGitVersionPlaceholder($raw, $logger))) {
            $replacements[$git] = self::retrieveGitVersion($path);
        }
        [$datetimeFormat, $valueSetByUser] = self::retrieveDatetimeFormat($raw, $logger);
        if (null !== ($date = self::retrieveDatetimeNowPlaceHolder($raw, $logger))) {
            $replacements[$date] = self::retrieveDatetimeNow($datetimeFormat);
        } elseif ($valueSetByUser) {
            $logger->addRecommendation(sprintf('The setting "%s" has been set but is unnecessary because the setting "%s" is not set.', self::DATETIME_FORMAT_KEY, self::DATETIME_KEY));
        }
        $sigil = self::retrieveReplacementSigil($raw, $logger);
        foreach ($replacements as $key => $value) {
            unset($replacements[$key]);
            $replacements[$sigil . $key . $sigil] = $value;
        }
        return $replacements;
    }
    private static function retrievePrettyGitPlaceholder(stdClass $raw, ConfigurationLogger $logger) : ?string
    {
        return self::retrievePlaceholder($raw, $logger, self::GIT_KEY);
    }
    private static function retrieveGitHashPlaceholder(stdClass $raw, ConfigurationLogger $logger) : ?string
    {
        return self::retrievePlaceholder($raw, $logger, self::GIT_COMMIT_KEY);
    }
    private static function retrieveGitHash(string $path, bool $short = \false) : string
    {
        return self::runGitCommand(sprintf('git log --pretty="%s" -n1 HEAD', $short ? '%h' : '%H'), $path);
    }
    private static function retrieveGitShortHashPlaceholder(stdClass $raw, ConfigurationLogger $logger) : ?string
    {
        return self::retrievePlaceholder($raw, $logger, self::GIT_COMMIT_SHORT_KEY);
    }
    private static function retrieveGitTagPlaceholder(stdClass $raw, ConfigurationLogger $logger) : ?string
    {
        return self::retrievePlaceholder($raw, $logger, self::GIT_TAG_KEY);
    }
    private static function retrievePlaceholder(stdClass $raw, ConfigurationLogger $logger, string $key) : ?string
    {
        self::checkIfDefaultValue($logger, $raw, $key);
        return $raw->{$key} ?? null;
    }
    private static function retrieveGitTag(string $path) : string
    {
        return self::runGitCommand('git describe --tags HEAD', $path);
    }
    private static function retrievePrettyGitTag(string $path) : string
    {
        $version = self::retrieveGitTag($path);
        if (preg_match('/^(?<tag>.+)-\\d+-g(?<hash>[a-f0-9]{7})$/', $version, $matches)) {
            return sprintf('%s@%s', $matches['tag'], $matches['hash']);
        }
        return $version;
    }
    private static function retrieveGitVersionPlaceholder(stdClass $raw, ConfigurationLogger $logger) : ?string
    {
        return self::retrievePlaceholder($raw, $logger, self::GIT_VERSION_KEY);
    }
    private static function retrieveGitVersion(string $path) : ?string
    {
        try {
            return self::retrieveGitTag($path);
        } catch (RuntimeException $exception) {
            try {
                return self::retrieveGitHash($path, \true);
            } catch (RuntimeException $exception) {
                throw new RuntimeException(sprintf('The tag or commit hash could not be retrieved from "%s": %s', $path, $exception->getMessage()), 0, $exception);
            }
        }
    }
    private static function retrieveDatetimeNowPlaceHolder(stdClass $raw, ConfigurationLogger $logger) : ?string
    {
        return self::retrievePlaceholder($raw, $logger, self::DATETIME_KEY);
    }
    private static function retrieveDatetimeNow(string $format) : string
    {
        return (new DateTimeImmutable('now', new DateTimeZone('UTC')))->format($format);
    }
    private static function retrieveDatetimeFormat(stdClass $raw, ConfigurationLogger $logger) : array
    {
        self::checkIfDefaultValue($logger, $raw, self::DATETIME_FORMAT_KEY, self::DEFAULT_DATETIME_FORMAT);
        self::checkIfDefaultValue($logger, $raw, self::DATETIME_FORMAT_KEY, self::DATETIME_FORMAT_DEPRECATED_KEY);
        if (isset($raw->{self::DATETIME_FORMAT_KEY})) {
            $format = $raw->{self::DATETIME_FORMAT_KEY};
        } elseif (isset($raw->{self::DATETIME_FORMAT_DEPRECATED_KEY})) {
            @trigger_error(sprintf('The "%s" is deprecated, use "%s" setting instead.', self::DATETIME_FORMAT_DEPRECATED_KEY, self::DATETIME_FORMAT_KEY), E_USER_DEPRECATED);
            $logger->addWarning(sprintf('The "%s" is deprecated, use "%s" setting instead.', self::DATETIME_FORMAT_DEPRECATED_KEY, self::DATETIME_FORMAT_KEY));
            $format = $raw->{self::DATETIME_FORMAT_DEPRECATED_KEY};
        } else {
            $format = null;
        }
        if (null !== $format) {
            $formattedDate = (new DateTimeImmutable())->format($format);
            Assert::false(\false === $formattedDate || $formattedDate === $format, sprintf('Expected the datetime format to be a valid format: "%s" is not', $format));
            return [$format, \true];
        }
        return [self::DEFAULT_DATETIME_FORMAT, \false];
    }
    private static function retrieveReplacementSigil(stdClass $raw, ConfigurationLogger $logger) : string
    {
        return self::retrievePlaceholder($raw, $logger, self::REPLACEMENT_SIGIL_KEY) ?? self::DEFAULT_REPLACEMENT_SIGIL;
    }
    private static function retrieveShebang(stdClass $raw, bool $stubIsGenerated, ConfigurationLogger $logger) : ?string
    {
        self::checkIfDefaultValue($logger, $raw, self::SHEBANG_KEY, self::DEFAULT_SHEBANG);
        if (\false === isset($raw->{self::SHEBANG_KEY})) {
            return self::DEFAULT_SHEBANG;
        }
        $shebang = $raw->{self::SHEBANG_KEY};
        if (\false === $shebang) {
            if (\false === $stubIsGenerated) {
                $logger->addRecommendation(sprintf('The "%s" has been set to `false` but is unnecessary since the Box built-in stub is not' . ' being used', self::SHEBANG_KEY));
            }
            return null;
        }
        Assert::string($shebang, 'Expected shebang to be either a string, false or null, found true');
        $shebang = trim($shebang);
        Assert::notEmpty($shebang, 'The shebang should not be empty.');
        Assert::true(str_starts_with($shebang, '#!'), sprintf('The shebang line must start with "#!". Got "%s" instead', $shebang));
        if (\false === $stubIsGenerated) {
            $logger->addWarning(sprintf('The "%s" has been set but ignored since it is used only with the Box built-in stub which is not' . ' used', self::SHEBANG_KEY));
        }
        return $shebang;
    }
    private static function retrieveSigningAlgorithm(stdClass $raw, ConfigurationLogger $logger) : int
    {
        if (property_exists($raw, self::ALGORITHM_KEY) && null === $raw->{self::ALGORITHM_KEY}) {
            self::addRecommendationForDefaultValue($logger, self::ALGORITHM_KEY);
        }
        if (\false === isset($raw->{self::ALGORITHM_KEY})) {
            return self::DEFAULT_SIGNING_ALGORITHM;
        }
        $algorithm = strtoupper($raw->{self::ALGORITHM_KEY});
        Assert::inArray($algorithm, array_keys(get_phar_signing_algorithms()));
        Assert::true(defined('Phar::' . $algorithm), sprintf('The signing algorithm "%s" is not supported by your current PHAR version.', $algorithm));
        $algorithm = constant('Phar::' . $algorithm);
        if (self::DEFAULT_SIGNING_ALGORITHM === $algorithm) {
            self::addRecommendationForDefaultValue($logger, self::ALGORITHM_KEY);
        }
        return $algorithm;
    }
    private static function retrieveStubBannerContents(stdClass $raw, bool $stubIsGenerated, ConfigurationLogger $logger) : ?string
    {
        self::checkIfDefaultValue($logger, $raw, self::BANNER_KEY, self::getDefaultBanner());
        if (\false === isset($raw->{self::BANNER_KEY})) {
            return self::getDefaultBanner();
        }
        $banner = $raw->{self::BANNER_KEY};
        if (\false === $banner) {
            if (\false === $stubIsGenerated) {
                $logger->addRecommendation(sprintf('The "%s" setting has been set but is unnecessary since the Box built-in stub is not ' . 'being used', self::BANNER_KEY));
            }
            return null;
        }
        Assert::true(is_string($banner) || is_array($banner), 'The banner cannot accept true as a value');
        if (is_array($banner)) {
            $banner = implode("\n", $banner);
        }
        if (\false === $stubIsGenerated) {
            $logger->addWarning(sprintf('The "%s" setting has been set but is ignored since the Box built-in stub is not being used', self::BANNER_KEY));
        }
        return $banner;
    }
    private static function getDefaultBanner() : string
    {
        return sprintf(self::DEFAULT_BANNER, get_box_version());
    }
    private static function retrieveStubBannerPath(stdClass $raw, string $basePath, bool $stubIsGenerated, ConfigurationLogger $logger) : ?string
    {
        self::checkIfDefaultValue($logger, $raw, self::BANNER_FILE_KEY);
        if (\false === isset($raw->{self::BANNER_FILE_KEY})) {
            return null;
        }
        $bannerFile = make_path_absolute($raw->{self::BANNER_FILE_KEY}, $basePath);
        Assert::file($bannerFile);
        if (\false === $stubIsGenerated) {
            $logger->addWarning(sprintf('The "%s" setting has been set but is ignored since the Box built-in stub is not being used', self::BANNER_FILE_KEY));
        }
        return $bannerFile;
    }
    private static function normalizeStubBannerContents(?string $contents) : ?string
    {
        if (null === $contents) {
            return null;
        }
        $banner = explode("\n", $contents);
        $banner = array_map('trim', $banner);
        return implode("\n", $banner);
    }
    private static function retrieveStubPath(stdClass $raw, string $basePath, ConfigurationLogger $logger) : ?string
    {
        self::checkIfDefaultValue($logger, $raw, self::STUB_KEY);
        if (isset($raw->{self::STUB_KEY}) && is_string($raw->{self::STUB_KEY})) {
            $stubPath = make_path_absolute($raw->{self::STUB_KEY}, $basePath);
            Assert::file($stubPath);
            return $stubPath;
        }
        return null;
    }
    private static function retrieveInterceptsFileFunctions(stdClass $raw, bool $stubIsGenerated, ConfigurationLogger $logger) : bool
    {
        self::checkIfDefaultValue($logger, $raw, self::INTERCEPT_KEY, \false);
        if (\false === isset($raw->{self::INTERCEPT_KEY})) {
            return \false;
        }
        $intercept = $raw->{self::INTERCEPT_KEY};
        if ($intercept && \false === $stubIsGenerated) {
            $logger->addWarning(sprintf('The "%s" setting has been set but is ignored since the Box built-in stub is not being used', self::INTERCEPT_KEY));
        }
        return $intercept;
    }
    private static function retrievePromptForPrivateKey(stdClass $raw, int $signingAlgorithm, ConfigurationLogger $logger) : bool
    {
        if (isset($raw->{self::KEY_PASS_KEY}) && \true === $raw->{self::KEY_PASS_KEY}) {
            if (Phar::OPENSSL !== $signingAlgorithm) {
                $logger->addWarning('A prompt for password for the private key has been requested but ignored since the signing ' . 'algorithm used is not "OPENSSL.');
                return \false;
            }
            return \true;
        }
        return \false;
    }
    private static function retrieveIsStubGenerated(stdClass $raw, ?string $stubPath, ConfigurationLogger $logger) : bool
    {
        self::checkIfDefaultValue($logger, $raw, self::STUB_KEY, \true);
        return null === $stubPath && (\false === isset($raw->{self::STUB_KEY}) || \false !== $raw->{self::STUB_KEY});
    }
    private static function retrieveCheckRequirements(stdClass $raw, bool $hasComposerJson, bool $hasComposerLock, bool $pharStubUsed, ConfigurationLogger $logger) : bool
    {
        self::checkIfDefaultValue($logger, $raw, self::CHECK_REQUIREMENTS_KEY, \true);
        if (\false === property_exists($raw, self::CHECK_REQUIREMENTS_KEY)) {
            return $hasComposerJson || $hasComposerLock;
        }
        $checkRequirements = $raw->{self::CHECK_REQUIREMENTS_KEY} ?? \true;
        if ($checkRequirements && \false === $hasComposerJson && \false === $hasComposerLock) {
            $logger->addWarning('The requirement checker could not be used because the composer.json and composer.lock file could not ' . 'be found.');
            return \false;
        }
        if ($checkRequirements && $pharStubUsed) {
            $logger->addWarning(sprintf('The "%s" setting has been set but has been ignored since the PHAR built-in stub is being ' . 'used.', self::CHECK_REQUIREMENTS_KEY));
        }
        return $checkRequirements;
    }
    private static function retrievePhpScoperConfig(stdClass $raw, string $basePath, ConfigurationLogger $logger) : PhpScoperConfiguration
    {
        self::checkIfDefaultValue($logger, $raw, self::PHP_SCOPER_KEY, self::PHP_SCOPER_CONFIG);
        if (!isset($raw->{self::PHP_SCOPER_KEY})) {
            $configFilePath = make_path_absolute(self::PHP_SCOPER_CONFIG, $basePath);
            $configFilePath = file_exists($configFilePath) ? $configFilePath : null;
            return self::createPhpScoperConfig($configFilePath);
        }
        $configFile = $raw->{self::PHP_SCOPER_KEY};
        Assert::string($configFile);
        $configFilePath = make_path_absolute($configFile, $basePath);
        Assert::file($configFilePath);
        Assert::readable($configFilePath);
        return self::createPhpScoperConfig($configFilePath);
    }
    private static function createPhpScoperConfig(?string $filePath) : PhpScoperConfiguration
    {
        $configFactory = (new Container())->getConfigurationFactory();
        try {
            return $configFactory->create($filePath);
        } catch (Throwable $throwable) {
            throw new InvalidArgumentException(sprintf('Could not create a PHP-Scoper config from the file "%s": %s', $filePath, $throwable->getMessage()), $throwable->getCode(), $throwable);
        }
    }
    private static function runGitCommand(string $command, string $path) : string
    {
        $process = Process::fromShellCommandline($command, $path);
        $process->run();
        if ($process->isSuccessful()) {
            return trim($process->getOutput());
        }
        throw new RuntimeException(sprintf('The tag or commit hash could not be retrieved from "%s": %s', $path, $process->getErrorOutput()), 0, new ProcessFailedException($process));
    }
    private static function retrievePhpCompactorIgnoredAnnotations(stdClass $raw, array $compactorClasses, ConfigurationLogger $logger) : array
    {
        $hasPhpCompactor = in_array(PhpCompactor::class, $compactorClasses, \true);
        self::checkIfDefaultValue($logger, $raw, self::ANNOTATIONS_KEY, \true);
        self::checkIfDefaultValue($logger, $raw, self::ANNOTATIONS_KEY, null);
        if (\false === property_exists($raw, self::ANNOTATIONS_KEY)) {
            return self::DEFAULT_IGNORED_ANNOTATIONS;
        }
        if (\false === $hasPhpCompactor) {
            $logger->addWarning(sprintf('The "%s" setting has been set but is ignored since no PHP compactor has been configured', self::ANNOTATIONS_KEY));
        }
        $annotations = $raw->{self::ANNOTATIONS_KEY};
        if (\true === $annotations || null === $annotations) {
            return self::DEFAULT_IGNORED_ANNOTATIONS;
        }
        if (\false === $annotations) {
            return [];
        }
        if (\false === property_exists($annotations, self::IGNORED_ANNOTATIONS_KEY)) {
            $logger->addWarning(sprintf('The "%s" setting has been set but no "%s" setting has been found, hence "%s" is treated as' . ' if it is set to `false`', self::ANNOTATIONS_KEY, self::IGNORED_ANNOTATIONS_KEY, self::ANNOTATIONS_KEY));
            return [];
        }
        $ignored = [];
        if (property_exists($annotations, self::IGNORED_ANNOTATIONS_KEY) && in_array($ignored = $annotations->{self::IGNORED_ANNOTATIONS_KEY}, [null, []], \true)) {
            self::addRecommendationForDefaultValue($logger, self::ANNOTATIONS_KEY . '#' . self::IGNORED_ANNOTATIONS_KEY);
            return (array) $ignored;
        }
        return $ignored;
    }
    private static function createPhpCompactor(array $ignoredAnnotations) : Compactor
    {
        $ignoredAnnotations = array_values(array_filter(array_map(static fn(string $annotation): ?string => \strtolower(trim($annotation)), $ignoredAnnotations)));
        return new PhpCompactor(new DocblockAnnotationParser(DocBlockFactory::createInstance(), new CompactedFormatter(), $ignoredAnnotations));
    }
    private static function createPhpScoperCompactor(stdClass $raw, string $basePath, ConfigurationLogger $logger) : Compactor
    {
        $phpScoperConfig = self::configurePhpScoperPrefix(self::retrievePhpScoperConfig($raw, $basePath, $logger));
        $whitelistedFiles = array_values(array_unique(array_map(static fn(string $path): string => make_path_relative($path, $basePath), array_keys($phpScoperConfig->getExcludedFilesWithContents()))));
        return new PhpScoperCompactor(new SerializableScoper($phpScoperConfig, ...$whitelistedFiles));
    }
    private static function configurePhpScoperPrefix(PhpScoperConfiguration $phpScoperConfig) : PhpScoperConfiguration
    {
        $prefix = $phpScoperConfig->getPrefix();
        if (!str_starts_with($prefix, '_PhpScoper')) {
            return $phpScoperConfig;
        }
        if (method_exists($phpScoperConfig, 'withPrefix')) {
            return $phpScoperConfig->withPrefix(unique_id('_HumbugBox'));
        }
        return new PhpScoperConfiguration($phpScoperConfig->getPath(), unique_id('_HumbugBox'), $phpScoperConfig->getFilesWithContents(), $phpScoperConfig->getExcludedFilesWithContents(), $phpScoperConfig->getPatcher(), $phpScoperConfig->getSymbolsConfiguration());
    }
    private static function checkIfDefaultValue(ConfigurationLogger $logger, stdClass $raw, string $key, $defaultValue = null) : void
    {
        if (\false === property_exists($raw, $key)) {
            return;
        }
        $value = $raw->{$key};
        if (null === $value || \false === is_object($defaultValue) && $defaultValue === $value || is_object($defaultValue) && $defaultValue == $value) {
            $logger->addRecommendation(sprintf('The "%s" setting can be omitted since is set to its default value', $key));
        }
    }
    private static function addRecommendationForDefaultValue(ConfigurationLogger $logger, string $key) : void
    {
        $logger->addRecommendation(sprintf('The "%s" setting can be omitted since is set to its default value', $key));
    }
}
