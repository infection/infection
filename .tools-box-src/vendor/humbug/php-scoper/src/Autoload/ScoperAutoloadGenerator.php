<?php

declare (strict_types=1);
namespace _HumbugBoxb47773b41c19\Humbug\PhpScoper\Autoload;

use _HumbugBoxb47773b41c19\Humbug\PhpScoper\Symbol\SymbolsRegistry;
use _HumbugBoxb47773b41c19\PhpParser\Node\Name\FullyQualified;
use function array_keys;
use function array_map;
use function array_unshift;
use function chr;
use function count;
use function explode;
use function implode;
use function is_string;
use function sprintf;
use function str_repeat;
use function str_replace;
use function usort;
final class ScoperAutoloadGenerator
{
    private const FUNCTION_ALIASES_DOC = <<<'EOF'
// Function aliases. For more information see:
// https://github.com/humbug/php-scoper/blob/master/docs/further-reading.md#function-aliases
EOF;
    private const CLASS_ALIASES_DOC = <<<'EOF'
// Class aliases. For more information see:
// https://github.com/humbug/php-scoper/blob/master/docs/further-reading.md#class-aliases
EOF;
    private const EXPOSE_CLASS_DECLARATION = <<<'PHP'
function humbug_phpscoper_expose_class(string $exposed, string $prefixed): void {
    if (!class_exists($exposed, false) && !interface_exists($exposed, false) && !trait_exists($exposed, false)) {
        spl_autoload_call($prefixed);
    }
}
PHP;
    private static string $eol;
    public function __construct(private readonly SymbolsRegistry $registry)
    {
        self::$eol = chr(10);
    }
    public function dump() : string
    {
        $exposedFunctions = self::sortExposedFunctions($this->registry->getRecordedFunctions());
        $wrapInNamespace = self::hasNamespacedFunctions($exposedFunctions);
        $statements = [...self::createClassAliasStatementsSection($this->registry->getRecordedClasses(), $wrapInNamespace), self::$eol, self::$eol, ...self::createFunctionAliasStatements($exposedFunctions, $wrapInNamespace)];
        $statements = implode(self::$eol, $statements);
        if ($wrapInNamespace) {
            $dump = <<<PHP
<?php

// scoper-autoload.php @generated by PhpScoper

namespace {
    // Backup the autoloaded Composer files
    if (isset(\$GLOBALS['__composer_autoload_files'])) {
        \$existingComposerAutoloadFiles = \$GLOBALS['__composer_autoload_files'];
    }

    \$loader = require_once __DIR__.'/autoload.php';
    // Ensure InstalledVersions is available
    require_once __DIR__.'/composer/InstalledVersions.php';

    // Restore the backup
    if (isset(\$existingComposerAutoloadFiles)) {
        \$GLOBALS['__composer_autoload_files'] = \$existingComposerAutoloadFiles;
    } else {
        unset(\$GLOBALS['__composer_autoload_files']);
    }
}

{$statements}

namespace {
    return \$loader;
}

PHP;
        } else {
            $dump = <<<PHP
<?php

// scoper-autoload.php @generated by PhpScoper

// Backup the autoloaded Composer files
if (isset(\$GLOBALS['__composer_autoload_files'])) {
    \$existingComposerAutoloadFiles = \$GLOBALS['__composer_autoload_files'];
}

\$loader = require_once __DIR__.'/autoload.php';
// Ensure InstalledVersions is available
require_once __DIR__.'/composer/InstalledVersions.php';

// Restore the backup
if (isset(\$existingComposerAutoloadFiles)) {
    \$GLOBALS['__composer_autoload_files'] = \$existingComposerAutoloadFiles;
} else {
    unset(\$GLOBALS['__composer_autoload_files']);
}

{$statements}

return \$loader;

PHP;
        }
        return self::removeUnnecessaryLineReturns($dump);
    }
    private static function sortExposedFunctions(array $exposedFunctions) : array
    {
        usort($exposedFunctions, static fn(array $a, array $b) => $a[0] <=> $b[0]);
        return $exposedFunctions;
    }
    private static function createClassAliasStatementsSection(array $exposedClasses, bool $wrapInNamespace) : array
    {
        $statements = self::createClassAliasStatements($exposedClasses);
        if (count($statements) === 0) {
            return [];
        }
        array_unshift($statements, self::EXPOSE_CLASS_DECLARATION);
        if ($wrapInNamespace) {
            $statements = self::wrapStatementsInNamespaceBlock('', $statements);
        }
        array_unshift($statements, self::CLASS_ALIASES_DOC);
        return $statements;
    }
    private static function createClassAliasStatements(array $exposedClasses) : array
    {
        return array_map(static fn(array $class) => self::createClassAliasStatement(...$class), $exposedClasses);
    }
    private static function createClassAliasStatement(string $exposed, string $prefixed) : string
    {
        return sprintf('humbug_phpscoper_expose_class(\'%s\', \'%s\');', $exposed, $prefixed);
    }
    private static function wrapStatementsInNamespaceBlock(string $namespace, string|array $statements) : array
    {
        if (is_string($statements)) {
            $statements = explode(self::$eol, $statements);
        }
        $indent = str_repeat(' ', 4);
        $indentLine = static fn(string $line) => $indent . $line;
        $statements = array_map(static function (string $statement) use($indentLine) : string {
            $parts = explode(self::$eol, $statement);
            return implode(self::$eol, array_map($indentLine, $parts));
        }, $statements);
        array_unshift($statements, sprintf('namespace %s{', '' === $namespace ? '' : $namespace . ' '));
        $statements[] = '}' . self::$eol;
        return $statements;
    }
    private static function createFunctionAliasStatements(array $exposedFunctions, bool $wrapInNamespace) : array
    {
        $functionsGroupedByNamespace = self::groupFunctionsByNamespace($exposedFunctions);
        $statements = array_map(static fn(string $namespace) => self::createNamespacedFunctionAliasStatement($wrapInNamespace, $namespace, $functionsGroupedByNamespace[$namespace]), array_keys($functionsGroupedByNamespace));
        if ([] === $statements) {
            return $statements;
        }
        array_unshift($statements, self::FUNCTION_ALIASES_DOC);
        return $statements;
    }
    private static function groupFunctionsByNamespace(array $exposedFunctions) : array
    {
        $groupedFunctions = [];
        foreach ($exposedFunctions as [$exposed, $prefix]) {
            $originalFQ = new FullyQualified($exposed);
            $namespace = $originalFQ->slice(0, -1);
            $functionName = null === $namespace ? $exposed : (string) $originalFQ->slice(1);
            $groupedFunctions[(string) $namespace][] = [$exposed, $functionName, $prefix];
        }
        return $groupedFunctions;
    }
    private static function createNamespacedFunctionAliasStatement(bool $wrapInNamespace, string $namespace, array $functions) : string
    {
        $statements = array_map(static fn(array $function) => self::createFunctionAliasStatement(...$function), $functions);
        if ($wrapInNamespace) {
            $statements = self::wrapStatementsInNamespaceBlock($namespace, $statements);
        }
        return implode(self::$eol, $statements);
    }
    private static function createFunctionAliasStatement(string $exposed, string $functionName, string $prefixed) : string
    {
        return sprintf(<<<'PHP'
if (!function_exists('%s')) { function %s(%s) { return \%s(...func_get_args()); } }
PHP
, $exposed, $functionName, '__autoload' === $functionName ? '$className' : '', $prefixed);
    }
    private static function hasNamespacedFunctions(array $functions) : bool
    {
        foreach ($functions as [$original, $alias]) {
            $containsBackslash = \str_contains($original, '\\');
            if ($containsBackslash) {
                return \true;
            }
        }
        return \false;
    }
    private static function removeUnnecessaryLineReturns(string $dump) : string
    {
        $cleanedDump = $dump;
        do {
            $dump = $cleanedDump;
            $cleanedDump = str_replace("\n\n\n", "\n\n", $dump);
        } while ($cleanedDump !== $dump);
        return $dump;
    }
}
